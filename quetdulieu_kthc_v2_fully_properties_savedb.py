# -*- coding: utf-8 -*-
"""QuetDuLieu_KTHC_V2_fully_properties_saveDB.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vuhnxlcN7QuOM73nxOKu5W45gw290rRi
"""

#Cài đặt các thư viện cần thiết
!pip install -U google-generativeai
!pip install PyMuPDF
!pip install pymssql
!pip install PyPDF2

import os
import google.generativeai as genai
import base64
from io import BytesIO
from PIL import Image
import fitz  # PyMuPDF
import pymssql
import json
import uuid
import time
import pandas as pd
# from IPython.display import display, Image
from PIL import Image
from datetime import datetime
import json
import unicodedata
import re

#Chạy đoạn này để kết nối tới tài khoản Google Drive chứa dữ liệu cần thêm
from google.colab import drive
drive.mount('/content/drive')

#Đăng nhập vào trang này để tạo API key https://aistudio.google.com/apikey
# genai.configure(api_key='điền-apikey')
genai.configure(api_key='AIzaSyAkiSkLZI-CvxlNdwRVL_yfT4gfL4SohMc')
model = genai.GenerativeModel(model_name="gemini-1.5-flash")

FIELD_MAPPING = {
    'VanBanID': 'Khóa chính(pk)',
    'VanBanCode': 'Mã định danh văn bản',
    'HoSoLuuTruID': 'Mã hồ sơ',
    'CoQuanID': 'Mã cơ quan lưu trữ lịch sử',
    'PhongLuuTruID': 'Mã phòng/công trình/sưu tập lưu trữ',
    'MucLucSoNSD': 'Mục lục sổ hoặc năm hình thành hồ sơ',
    'SoVaKyHieuHS': 'Số và ký hiệu hồ sơ',
    'SoTTVBTrongHS': 'Số thứ tự văn bản trong hồ sơ',
    'LoaiVanBanID': 'Tên loại văn bản',
    'ToSo': 'Số của văn bản',
    'KyHieuVanBan': 'Ký hiệu của văn bản',
    'NgayKy': 'Ngày, tháng, năm của văn bản',
    'CoQuanBanHanh': 'Tên cơ quan, tổ chức ban hành văn bản',
    'TrichYeu': 'Trích yếu nội dung',
    'NgonNguID': 'Ngôn ngữ',
    'SoLuongTrang': 'Số lượng trang của văn bản',
    'GhiChu': 'Ghi chú',
    'KyHieuThongTin': 'Ký hiệu thông tin',
    'TuKhoa': 'Từ khóa',
    'CheDoSuDungID': 'Chế độ sử dụng',
    'MucDoTinCayID': 'Mức độ tin cậy',
    'ButTich': 'Bút tích',
    'TinhTrangVatLyID': 'Tình trạng vật lý',
    'DinhKem': 'Tệp đính kèm',
    'UserID': 'User thao tác',
    'DonViID': 'Đơn vị thao tác',
    'NgayThaoTac': 'Thời gian thao tác',
    'NoiDung': '//',
    'NguoiKy': 'Người ký',
    'PhanQuyen': 'Phân quyền',
    'SoHieuVanBan': 'Số hiệu văn bản'
}

import fitz  # PyMuPDF
from PIL import Image
from io import BytesIO
import base64

def readTextFromPdf(file_path, pages=None):
    all_text = ""
    doc = fitz.open(file_path)  # Mở file PDF bằng PyMuPDF
    total_pages = len(doc)

    # Nếu không chỉ định trang nào, mặc định đọc toàn bộ
    if pages is None:
        pages = list(range(1, total_pages + 1))

    text_found = False

    for page_num in pages:
        if 1 <= page_num <= total_pages:
            page = doc.load_page(page_num - 1)
            page_text = page.get_text("text")
            if page_text:
                text_found = True
                all_text += page_text + "\n"

    if text_found:
        print(">>>>>>>>KHÔNG DÙNG AI ĐỂ LẤY NỘI DUNG PDF")
        return all_text, total_pages
    else:
        print(">>>>>>>>DÙNG AI ĐỂ LẤY NỘI DUNG PDF")
        for page_num in pages:
            if 1 <= page_num <= total_pages:
                page = doc[page_num - 1]
                pix = page.get_pixmap(matrix=fitz.Matrix(300/72, 300/72), alpha=False)
                img = Image.frombuffer("RGB", [pix.width, pix.height], pix.samples, "raw", "RGB", 0, 1)
                buffered = BytesIO()
                img.save(buffered, format="PNG")
                img_str = base64.b64encode(buffered.getvalue()).decode()

                promptText = """
                # Yêu cầu:
                Bạn sẽ nhận một file PDF chứa văn bản hành chính (có thể là Quyết định, Công văn, Thông tư, ...). Hãy đọc **chính xác 100% nội dung theo từng dòng từ trái sang phải** của tài liệu.

                ## I. Thông tin cần trích xuất (theo từng trường):
                1. TieuDeHoSo: Tóm tắt ngắn gọn nội dung chính
                2. SoVaKyHieu: Số và ký hiệu chính thức
                3. LoaiVanBan: Quyết định, Công văn, Thông tư, Nghị định,...
                4. NgayVanBan: Ngày ban hành (dd/mm/yyyy)
                5. CoQuanBanHanh: Tên cơ quan, tổ chức ban hành
                6. HoTenNguoiKy: Họ và tên đầy đủ người ký
                7. ChucVuNguoiKy: Chức danh người ký (ví dụ: Giám đốc, Trưởng phòng,...).
                Lưu ý: Nếu văn bản có ghi "Chủ đầu tư" thì KHÔNG coi là chức danh, mà là vai trò pháp lý trong dự án.
                Khi đó, ChucVuNguoiKy sẽ là chức vụ theo sau vai trò pháp lý đó.
                8. NgonNgu: Ngôn ngữ chính của văn bản
                9. MaHoSo: Mã hồ sơ chứa văn bản
                10. TongSoTrang: Tổng số trang trong văn bản
                11. GhiChu: Các thông tin bổ sung khác (nếu có)

                ## II. Định dạng kết quả:
                - Trả kết quả dưới dạng **JSON** với các key như trên
                - Nếu không đọc được trường nào, để trống hoặc ghi ""
                - Luôn trả về định dạng với ngôn ngữ là tiếng việt
                ## III. Lưu ý đặc biệt:
                - Nếu văn bản bị nghiêng, mờ, cần tự động hiệu chỉnh trước khi đọc
                - Không được bỏ sót bất kỳ dòng nào chứa thông tin liên quan đến các trường ở trên
                - Nếu văn bản có ô lựa chọn kiểu [ ] hoặc [X], hãy giữ đúng định dạng đó
                """

                response = model.generate_content([
                    {'mime_type': 'image/png', 'data': img_str},
                    promptText
                ])
                all_text += response.text + "\n"

        return all_text, total_pages

# prompt: Dùng OpenAI để chat với nội dung "Xin chào"
from openai import OpenAI

# Get the OpenAI API key from environment variables
openai_api_key = "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"
def chat_with_openai_json(prompt) -> str:
  # Khởi tạo mô hình ChatOpenAI
  client = OpenAI(api_key=openai_api_key)
  response = client.chat.completions.create(
                model="gpt-4o-mini",
                temperature = 0,
                response_format={"type": "json_object"},
                messages=[
                    {"role": "system", "content": """Bạn là 1 kế toán hành chính chuyên nghiệp, có kinh nghiệm 20 năm trong lĩnh vực kế toán"""},
                    {"role": "user", "content": prompt} # Adding "Trả về kết quả dưới dạng json" to the user message
                ]
              )
  return response.choices[0].message.content

def get_gemini_response(prompt):
  # Tạo một instance của model
  #model = genai.GenerativeModel(model_name="gemini-1.5-flash")

  # Gửi yêu cầu và nhận phản hồi
  response = model.generate_content(prompt)

  # Trả về phản hồi
  return response.text

# Thông tin kết nối Database
server = '103.162.21.146:1435'
database = 'ProOnline_daotao'
username = 'sa'
password = 'SerzerNTS2024MGH@da!SQL'
listUser = []
try:
    # Kết nối tới SQL Server
    conn = pymssql.connect(server=server, user=username, password=password, database=database)
    cursor = conn.cursor()
    print("Kết nối thành công!")
    # lấy danh mục địa bàn
    cursor.execute('''
    select tenDangNhap, maNguoidungpr=convert(nvarchar(18), maNguoidungpr) from UserProOnline_daotao.dbo.tblusers
    ''')
    listUser = cursor.fetchall()

    # Đóng kết nối
    conn.close()
    #print(listUser)
    jsonArray_User = json.dumps(listUser, ensure_ascii=False)
    print(jsonArray_User)
except Exception as e:
    #conn.close()
    print("Lỗi khi kết nối hoặc thao tác:", e)

from datetime import datetime
from typing import Optional

def convert_date_for_sql(input_date: str) -> Optional[str]:
    """
    Chuyển chuỗi ngày từ định dạng dd/MM/yyyy hoặc dd/M/yyyy thành yyyy/MM/dd.
    Nếu không hợp lệ, trả về None (để dùng NULL trong câu SQL).

    Args:
        input_date (str): Chuỗi ngày cần chuyển đổi.

    Returns:
        Optional[str]: Chuỗi ngày theo dạng yyyy/MM/dd hoặc None nếu không hợp lệ.
    """
    try:
        # Cố gắng parse ngày tháng
        parsed_date = datetime.strptime(input_date, "%d/%m/%Y")
        # Định dạng lại theo yyyy/MM/dd
        return parsed_date.strftime("%Y/%m/%d")
    except (ValueError, TypeError):
        # Nếu không parse được, trả về None
        return None

print(convert_date_for_sql("14/1/2025"))

def save_to_database(cursor, mapped_data, fields, insert_query):
    """
    Lưu dữ liệu vào cơ sở dữ liệu.

    Args:
        cursor: Cursor của kết nối database
        mapped_data (dict): Dictionary chứa dữ liệu đã được map
        fields (list): Danh sách các trường cần insert
        insert_query (str): Câu query insert

    Returns:
        tuple: (bool, str) - (True/False thành công, message)
    """
    try:
        # Chuẩn bị giá trị theo thứ tự của fields
        values = [mapped_data.get(field, "") for field in fields]

        # Thực thi câu lệnh INSERT
        cursor.execute(insert_query, values)
        return True, "Lưu dữ liệu thành công"

    except Exception as e:
        return False, f"Lỗi khi lưu dữ liệu: {str(e)}"

def XuLyDuLieu_TuThuMuc(folder_path, skip_database=False):
    allFile = 0
    success = 0
    fail = 0
    mang = []
    errArr = []
    errData = ""

    # Thông tin kết nối Database
    server = '103.162.21.146:1435'
    database = 'ProOnline_daotao'
    username = 'sa'
    password = 'SerzerNTS2024MGH@da!SQL'

    try:
        # Kết nối tới SQL Server
        conn = pymssql.connect(server=server, user=username, password=password, database=database)
        cursor = conn.cursor()
        print("Kết nối database thành công!")

        # Tạo câu lệnh INSERT động dựa trên các trường trong FIELD_MAPPING
        fields = list(FIELD_MAPPING.keys())
        placeholders = ', '.join(['%s'] * len(fields))
        insert_query = f"""
        INSERT INTO tblVanBan (
            {', '.join(fields)}
        ) VALUES ({placeholders})
        """

        # Lặp qua tất cả các file và thư mục con trong thư mục
        for root, dirs, files in os.walk(folder_path):
            stt = 1
            print(f'>>>>>>> {os.path.basename(root)} <<<<<<<')
            for file in files:
                # Kiểm tra xem file có phải là file PDF không
                if file.endswith('.pdf'):
                    allFile += 1
                    # In ra đường dẫn đầy đủ của file PDF
                    file_path = os.path.join(root, file)
                    print(">>>>>>> Đang xử lý file: " + file_path)
                    item = {
                        "DuongDan": file_path,
                        "QuetDuLieu": 0,
                        "ThemDuLieu": 0,
                        "TrangThai": "",
                        "ThongTin": {}
                    }
                    try:
                        errData = ""
                        # Đọc dữ liệu từ PDF
                        dataORC, total_pages = readTextFromPdf(file_path, pages={1,2,3})
                        item["QuetDuLieu"] = 1

                        # Lấy dữ liệu số hóa từ AI
                        duLieuSoHoa = chat_with_openai_json(
                            """Bạn là kế toán viên cao cấp có 20 năm kinh nghiệm làm việc tại cơ quan nhà nước hãy giúp tôi thực hiện nhiệm vụ sau:
                            - Bước 1: Đọc toàn bộ **Dữ liệu về hồ sơ quyết toán** bên dưới
                            **Dữ liệu hồ sơ quyết toán**
                            ```
                            """ + dataORC + """
                            ```
                            - Bước 2: Suy luận toàn bộ **Dữ liệu hồ sơ quyết toán** và đảm bảo hiểu được chứng từ
                            - Bước 3: Trích xuất thông tin dưới định dạng JSON theo cấu trúc ở (Bước 4)
                            - Bước 4: Chỉ xuất JSON, không giải thích (không định dạng markdown):
                            ```
                            {
                              "ThongTinChung": {
                                "TieuDeHoSo": "Tóm tắt ngắn gọn nội dung chính của văn bản hoặc hồ sơ.",
                                "SoVaKyHieu": "Số và ký hiệu chính thức của văn bản.",
                                "LoaiVanBan": "Ví dụ: Quyết định, Công văn, Thông tư, Nghị định,...",
                                "NgayVanBan": "Ngày ban hành văn bản.",
                                "CoQuanBanHanh": "Đơn vị chủ quản ban hành văn bản đó.",
                                "HoTenNguoiKy": "Họ và tên đầy đủ của người ký văn bản.",
                                "ChucVuNguoiKy": "Chức danh của người ký văn bản.",
                                "NgonNgu": "Ngôn ngữ chính của văn bản (ví dụ: Tiếng Việt).",
                                "MaHoSo": "Mã của hồ sơ chứa văn bản đó.",
                                "TongSoTrang": "Số lượng trang của văn bản gốc.",
                                "GhiChu": "Các thông tin bổ sung cần thiết khác."
                              }
                            }
                            ```
                            **Lưu ý:**
                            + Không định dạng markdown
                            + Nếu các thông tin ở đầu ra tôi yêu cầu mà bạn không tìm thấy cứ việc trả về giá trị là chuỗi rỗng `""`
                            """)

                        # Parse kết quả trả về từ AI
                        try:
                            data_json = json.loads(duLieuSoHoa)
                            thong_tin_chung = data_json.get("ThongTinChung", {})
                            item["ThongTin"] = thong_tin_chung
                        except Exception as e:
                            print(f"Lỗi parse JSON từ AI: {e}")
                            thong_tin_chung = {}
                            item["TrangThai"] = f"Lỗi parse JSON: {str(e)}"

                        # Map dữ liệu vào dict chuẩn theo FIELD_MAPPING
                        mapped_data = {}

                        # Tạo các giá trị mặc định
                        current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

                        # Map các trường từ AI và các giá trị mặc định
                        mapping_rules = {
                            # Các trường từ AI
                            'TieuDeHoSo': ('TrichYeu', lambda x: x),
                            'SoVaKyHieu': ('SoVaKyHieuHS', lambda x: x),
                            'LoaiVanBan': ('LoaiVanBanID', lambda x: x),
                            'NgayVanBan': ('NgayKy', lambda x: convert_date_for_sql(x) if x else ""),
                            'CoQuanBanHanh': ('CoQuanBanHanh', lambda x: x),
                            'HoTenNguoiKy': ('NguoiKy', lambda x: x),
                            'ChucVuNguoiKy': ('GhiChu', lambda x: x),
                            'NgonNgu': ('NgonNguID', lambda x: x),
                            'MaHoSo': ('HoSoLuuTruID', lambda x: x),
                            'TongSoTrang': ('SoLuongTrang', lambda x: str(total_pages)),

                            # Các trường mặc định
                            'VanBanID': ('VanBanID', lambda x: str(uuid.uuid4())),
                            'VanBanCode': ('VanBanCode', lambda x: f"VB_{datetime.now().strftime('%Y%m%d%H%M%S')}"),
                            'NgayThaoTac': ('NgayThaoTac', lambda x: current_time),
                            'NoiDung': ('NoiDung', lambda x: ""),  # Để trống vì đã map vào các trường khác
                            'DinhKem': ('DinhKem', lambda x: file_path),  # Lưu đường dẫn file
                        }

                        # Áp dụng các quy tắc mapping
                        for ai_field, (db_field, transform_func) in mapping_rules.items():
                            if ai_field in thong_tin_chung:
                                mapped_data[db_field] = transform_func(thong_tin_chung[ai_field])
                            else:
                                mapped_data[db_field] = transform_func(None)

                        # Đảm bảo tất cả các trường trong FIELD_MAPPING đều có mặt trong dict trả về
                        for db_field in FIELD_MAPPING.keys():
                            if db_field not in mapped_data:
                                mapped_data[db_field] = ""

                        # In ra dữ liệu đã được map
                        print("\nDữ liệu đã được map:")
                        print(json.dumps(mapped_data, indent=2, ensure_ascii=False))
                        print("\n" + "="*50 + "\n")

                        # Nếu skip_database=True thì bỏ qua việc lưu vào database
                        if skip_database:
                            print(f"Bỏ qua việc lưu dữ liệu của file: {file} (skip_database=True)")
                            success += 1
                            item["TrangThai"] = "Thành công (Bỏ qua lưu DB)"
                            item["ThemDuLieu"] = 0
                            mang.append(item)
                            continue

                        # Lưu dữ liệu vào database ngay sau khi xử lý xong một file
                        try:
                            success_save, message = save_to_database(cursor, mapped_data, fields, insert_query)
                            if success_save:
                                success += 1
                                print(f"Đã lưu thành công dữ liệu của file: {file}")
                                item["TrangThai"] = "Thành công"
                                item["ThemDuLieu"] = 1
                            else:
                                fail += 1
                                print(f"Lỗi khi lưu dữ liệu của file {file}: {message}")
                                item["TrangThai"] = f"Lỗi: {message}"
                                item["ThemDuLieu"] = 0
                                mang.append(item)
                                continue

                            # Commit sau mỗi lần insert thành công
                            conn.commit()
                            mang.append(item)

                        except Exception as e:
                            print(f'{stt}: X {file_path} - Lỗi: {e} - data: {errData} ')
                            fail += 1
                            item["TrangThai"] = f"Lỗi: {str(e)}"
                            item["ThemDuLieu"] = 0
                            mang.append(item)

                    except Exception as e:
                        print(f'{stt}: X {file_path} - Lỗi: {e} - data: {errData} ')
                        fail += 1
                        item["TrangThai"] = f"Lỗi: {str(e)}"
                        item["ThemDuLieu"] = 0
                        mang.append(item)

        print(f"\nTổng kết:")
        print(f"Tổng số file: {allFile}")
        print(f"Số file xử lý thành công: {success}")
        print(f"Số file xử lý thất bại: {fail}")

        # In ra mảng kết quả
        print("\nChi tiết xử lý:")
        print(json.dumps(mang, indent=2, ensure_ascii=False))

    except Exception as e:
        print(f"Lỗi kết nối hoặc thao tác với database: {str(e)}")
    finally:
        if 'conn' in locals():
            conn.close()
            print("Đã đóng kết nối database")

    return mang

XuLyDuLieu_TuThuMuc('/content/drive/MyDrive/PDF_File/NTSOFT/KTHC', skip_database=True)